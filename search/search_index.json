{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Accompanist is a group of libraries that contains some utilities which I've found myself copying around projects which use Jetpack Compose . Currently, it contains: Image loading \u00b6 A number of libraries which integrate popular image loading libraries into Jetpack Compose: \ud83d\uddbc\ufe0f Coil image loading composables \ud83d\uddbc\ufe0f Picasso image loading composables \ud83d\uddbc\ufe0f Glide image loading composables \ud83d\udcd0 Insets \u00b6 A library which brings WindowInsets support to Jetpack Compose. Jetpack Compose is a fast-moving project and I'll be updating these libraries to match the latest tagged release as quickly as possible. Each release listing will outline what version of Compose libraries it depends on. Accompanist Snapshots \u00b6 Snapshots of the current development version of Accompanist are available, which track the latest commit. See here for more information. Why the name? \u00b6 The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#image-loading","text":"A number of libraries which integrate popular image loading libraries into Jetpack Compose: \ud83d\uddbc\ufe0f Coil image loading composables \ud83d\uddbc\ufe0f Picasso image loading composables \ud83d\uddbc\ufe0f Glide image loading composables","title":"Image loading"},{"location":"#insets","text":"A library which brings WindowInsets support to Jetpack Compose. Jetpack Compose is a fast-moving project and I'll be updating these libraries to match the latest tagged release as quickly as possible. Each release listing will outline what version of Compose libraries it depends on.","title":"\ud83d\udcd0 Insets"},{"location":"#accompanist-snapshots","text":"Snapshots of the current development version of Accompanist are available, which track the latest commit. See here for more information.","title":"Accompanist Snapshots"},{"location":"#why-the-name","text":"The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name.","title":"Why the name?"},{"location":"#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"#license","text":"Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"appcompat-theme/","text":"AppCompat Compose Theme Adapter \u00b6 A library that enables reuse of AppCompat XML themes for theming in Jetpack Compose . The basis of theming in Jetpack Compose is the MaterialTheme composable, where you provide Colors , Shapes and Typography instances containing your styling parameters: MaterialTheme ( typography = type , colors = colors , shapes = shapes ) { // Surface, Scaffold, etc } AppCompat XML themes allow for similar but coarser theming via XML theme attributes, like so: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat.DayNight\" > <item name= \"colorPrimary\" > @color/purple_500 </item> <item name= \"colorAccent\" > @color/green_200 </item> </style> This library attempts to bridge the gap between AppCompat XML themes, and themes in Jetpack Compose , allowing your composable MaterialTheme to be based on the Activity 's XML theme: AppCompatTheme { // MaterialTheme.colors, MaterialTheme.shapes, MaterialTheme.typography // will now contain copies of the context's theme } This is especially handy when you're migrating an existing app, a fragment (or other UI container) at a time. Caution If you are using Material Design Components in your app, you should use the MDC Compose Theme Adapter instead, as it allows much finer-grained reading of your theme. Customizing the theme \u00b6 The AppCompatTheme() function will automatically read the host context's AppCompat theme and pass them to MaterialTheme on your behalf, but if you want to customize the generated values, you can do so via the createAppCompatTheme() function: val context = LocalContext . current var ( colors , type ) = context . createAppCompatTheme () // Modify colors or type as required. Then pass them // through to MaterialTheme... MaterialTheme ( colors = colors , typography = type ) { // rest of layout } Generated theme \u00b6 Synthesizing a material theme from a Theme.AppCompat theme is not perfect, since Theme.AppCompat does not expose the same level of customization as is available in material theming. Going through the pillars of material theming: Colors \u00b6 AppCompat has a limited set of top-level color attributes, which means that AppCompatTheme() has to generate/select alternative colors in certain situations. The mapping is currently: MaterialTheme color AppCompat attribute primary colorPrimary primaryVariant colorPrimaryDark onPrimary Calculated black/white secondary colorAccent secondaryVariant colorAccent onSecondary Calculated black/white surface Default onSurface android:textColorPrimary , else calculated black/white background android:colorBackground onBackground android:textColorPrimary , else calculated black/white error colorError onError Calculated black/white Where the table says \"calculated black/white\", this means either black/white, depending on which provides the greatest contrast against the corresponding background color. Typography \u00b6 AppCompat does not provide any semantic text appearances (such as headline6, body1, etc), and instead relies on text appearances for specific widgets or use cases. As such, the only thing we read from an AppCompat theme is the default app:fontFamily or android:fontFamily . For example: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat\" > <item name= \"fontFamily\" > @font/my_font </item> </style> Compose does not currently support downloadable fonts, so any font referenced from the theme should from your resources. See here for more information. Shape \u00b6 AppCompat has no concept of shape theming, therefore we use the default value from MaterialTheme.shapes . If you wish to provide custom values, use the shapes parameter on AppCompatTheme . Limitations \u00b6 There are some known limitations with the implementation at the moment: This relies on your Activity / Context theme extending one of the Theme.AppCompat themes. Variable fonts are not supported in Compose yet, meaning that the value of android:fontVariationSettings are currently ignored. You can modify the resulting MaterialTheme in Compose as required, but this only works in Compose. Any changes you make will not be reflected in the Activity theme. Usage \u00b6 repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-appcompat-theme:<version>\" } Library Snapshots \u00b6 Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"AppCompat Theme"},{"location":"appcompat-theme/#appcompat-compose-theme-adapter","text":"A library that enables reuse of AppCompat XML themes for theming in Jetpack Compose . The basis of theming in Jetpack Compose is the MaterialTheme composable, where you provide Colors , Shapes and Typography instances containing your styling parameters: MaterialTheme ( typography = type , colors = colors , shapes = shapes ) { // Surface, Scaffold, etc } AppCompat XML themes allow for similar but coarser theming via XML theme attributes, like so: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat.DayNight\" > <item name= \"colorPrimary\" > @color/purple_500 </item> <item name= \"colorAccent\" > @color/green_200 </item> </style> This library attempts to bridge the gap between AppCompat XML themes, and themes in Jetpack Compose , allowing your composable MaterialTheme to be based on the Activity 's XML theme: AppCompatTheme { // MaterialTheme.colors, MaterialTheme.shapes, MaterialTheme.typography // will now contain copies of the context's theme } This is especially handy when you're migrating an existing app, a fragment (or other UI container) at a time. Caution If you are using Material Design Components in your app, you should use the MDC Compose Theme Adapter instead, as it allows much finer-grained reading of your theme.","title":"AppCompat Compose Theme Adapter"},{"location":"appcompat-theme/#customizing-the-theme","text":"The AppCompatTheme() function will automatically read the host context's AppCompat theme and pass them to MaterialTheme on your behalf, but if you want to customize the generated values, you can do so via the createAppCompatTheme() function: val context = LocalContext . current var ( colors , type ) = context . createAppCompatTheme () // Modify colors or type as required. Then pass them // through to MaterialTheme... MaterialTheme ( colors = colors , typography = type ) { // rest of layout }","title":"Customizing the theme"},{"location":"appcompat-theme/#generated-theme","text":"Synthesizing a material theme from a Theme.AppCompat theme is not perfect, since Theme.AppCompat does not expose the same level of customization as is available in material theming. Going through the pillars of material theming:","title":"Generated theme"},{"location":"appcompat-theme/#colors","text":"AppCompat has a limited set of top-level color attributes, which means that AppCompatTheme() has to generate/select alternative colors in certain situations. The mapping is currently: MaterialTheme color AppCompat attribute primary colorPrimary primaryVariant colorPrimaryDark onPrimary Calculated black/white secondary colorAccent secondaryVariant colorAccent onSecondary Calculated black/white surface Default onSurface android:textColorPrimary , else calculated black/white background android:colorBackground onBackground android:textColorPrimary , else calculated black/white error colorError onError Calculated black/white Where the table says \"calculated black/white\", this means either black/white, depending on which provides the greatest contrast against the corresponding background color.","title":"Colors"},{"location":"appcompat-theme/#typography","text":"AppCompat does not provide any semantic text appearances (such as headline6, body1, etc), and instead relies on text appearances for specific widgets or use cases. As such, the only thing we read from an AppCompat theme is the default app:fontFamily or android:fontFamily . For example: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat\" > <item name= \"fontFamily\" > @font/my_font </item> </style> Compose does not currently support downloadable fonts, so any font referenced from the theme should from your resources. See here for more information.","title":"Typography"},{"location":"appcompat-theme/#shape","text":"AppCompat has no concept of shape theming, therefore we use the default value from MaterialTheme.shapes . If you wish to provide custom values, use the shapes parameter on AppCompatTheme .","title":"Shape"},{"location":"appcompat-theme/#limitations","text":"There are some known limitations with the implementation at the moment: This relies on your Activity / Context theme extending one of the Theme.AppCompat themes. Variable fonts are not supported in Compose yet, meaning that the value of android:fontVariationSettings are currently ignored. You can modify the resulting MaterialTheme in Compose as required, but this only works in Compose. Any changes you make will not be reflected in the Activity theme.","title":"Limitations"},{"location":"appcompat-theme/#usage","text":"repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-appcompat-theme:<version>\" }","title":"Usage"},{"location":"appcompat-theme/#library-snapshots","text":"Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them.","title":"Library Snapshots"},{"location":"appcompat-theme/#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"appcompat-theme/#license","text":"Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"coil/","text":"Coil for Jetpack Compose \u00b6 This library brings easy-to-use composable which can fetch and display images from external sources, such as network, using the Coil image loading library. CoilImage() \u00b6 The primary API is via the CoilImage() functions. There are a number of function versions available. The simplest usage is like so: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" ) This loads the data passed in with Coil , and then displays the resulting image using the standard Image composable. You can also customize the Coil ImageRequest through the requestBuilder parameter. This allows usage of things like (but not limited to) transformations: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , requestBuilder = { transformations ( CircleCropTransformation ()) } ) It also provides optional content 'slots', allowing you to provide custom content to be displayed when the request is loading, and/or if the image request failed: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , loading = { Box ( Modifier . matchParentSize ()) { CircularProgressIndicator ( Modifier . align ( Alignment . Center )) } }, error = { Image ( asset = imageResource ( R . drawable . ic_error )) } ) Fade-in animation \u00b6 This library has built-in support for animating loaded images in, using a fade-in animation . There are two ways to enable the animation: fadeIn parameter \u00b6 A fadeIn: Boolean parameter has been added to CoilImage (default: false ). When enabled, a default fade-in animation will be used when the image is successfully loaded: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , fadeIn = true ) Custom content \u00b6 If you need more control over the animation, or you want to provide custom layout for the loaded image, you can use the content composable version of CoilImage : CoilImage ( data = \"https://picsum.photos/300/300\" , ) { imageState -> when ( imageState ) { is ImageLoadState . Success -> { MaterialLoadingImage ( result = imageState , contentDescription = \"My content description\" , fadeInEnabled = true , fadeInDurationMs = 600 , ) } is ImageLoadState . Error -> /* TODO */ ImageLoadState . Loading -> /* TODO */ ImageLoadState . Empty -> /* TODO */ } } GIFs \u00b6 Accompanist Coil supports GIFs through Coil's own GIF support. Follow the setup instructions and it should just work. Custom ImageLoader \u00b6 If you wish to provide a default ImageLoader to use across all of your CoilImage calls, we provide the LocalImageLoader composition local. You can use it like so: val imageLoader = ImageLoader . Builder ( context ) // customize the ImageLoader as needed . build () CompositionLocalProvider ( LocalImageLoader provides imageLoader ) { // This will automatically use the value of LocalImageLoader CoilImage ( data = ... ) } For more information on composition locals, see here . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-coil:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit. What's the goal of the library? \u00b6 Eventually the goal is to upstream all of this functionality back to Coil . Jetpack Compose 's development is currently moving very fast, which means that there are frequent API changes between releases. For now, it makes sense to keep this as a seperately released library to track the latest Compose release.","title":"Coil"},{"location":"coil/#coil-for-jetpack-compose","text":"This library brings easy-to-use composable which can fetch and display images from external sources, such as network, using the Coil image loading library.","title":"Coil for Jetpack Compose"},{"location":"coil/#coilimage","text":"The primary API is via the CoilImage() functions. There are a number of function versions available. The simplest usage is like so: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" ) This loads the data passed in with Coil , and then displays the resulting image using the standard Image composable. You can also customize the Coil ImageRequest through the requestBuilder parameter. This allows usage of things like (but not limited to) transformations: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , requestBuilder = { transformations ( CircleCropTransformation ()) } ) It also provides optional content 'slots', allowing you to provide custom content to be displayed when the request is loading, and/or if the image request failed: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , loading = { Box ( Modifier . matchParentSize ()) { CircularProgressIndicator ( Modifier . align ( Alignment . Center )) } }, error = { Image ( asset = imageResource ( R . drawable . ic_error )) } )","title":"CoilImage()"},{"location":"coil/#fade-in-animation","text":"This library has built-in support for animating loaded images in, using a fade-in animation . There are two ways to enable the animation:","title":"Fade-in animation"},{"location":"coil/#fadein-parameter","text":"A fadeIn: Boolean parameter has been added to CoilImage (default: false ). When enabled, a default fade-in animation will be used when the image is successfully loaded: CoilImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , fadeIn = true )","title":"fadeIn parameter"},{"location":"coil/#custom-content","text":"If you need more control over the animation, or you want to provide custom layout for the loaded image, you can use the content composable version of CoilImage : CoilImage ( data = \"https://picsum.photos/300/300\" , ) { imageState -> when ( imageState ) { is ImageLoadState . Success -> { MaterialLoadingImage ( result = imageState , contentDescription = \"My content description\" , fadeInEnabled = true , fadeInDurationMs = 600 , ) } is ImageLoadState . Error -> /* TODO */ ImageLoadState . Loading -> /* TODO */ ImageLoadState . Empty -> /* TODO */ } }","title":"Custom content"},{"location":"coil/#gifs","text":"Accompanist Coil supports GIFs through Coil's own GIF support. Follow the setup instructions and it should just work.","title":"GIFs"},{"location":"coil/#custom-imageloader","text":"If you wish to provide a default ImageLoader to use across all of your CoilImage calls, we provide the LocalImageLoader composition local. You can use it like so: val imageLoader = ImageLoader . Builder ( context ) // customize the ImageLoader as needed . build () CompositionLocalProvider ( LocalImageLoader provides imageLoader ) { // This will automatically use the value of LocalImageLoader CoilImage ( data = ... ) } For more information on composition locals, see here .","title":"Custom ImageLoader"},{"location":"coil/#download","text":"repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-coil:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"coil/#whats-the-goal-of-the-library","text":"Eventually the goal is to upstream all of this functionality back to Coil . Jetpack Compose 's development is currently moving very fast, which means that there are frequent API changes between releases. For now, it makes sense to keep this as a seperately released library to track the latest Compose release.","title":"What's the goal of the library?"},{"location":"contributing/","text":"How to Contribute \u00b6 We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow. Contributor License Agreement \u00b6 Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again. Code reviews \u00b6 All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.","title":"How to Contribute"},{"location":"contributing/#contributor-license-agreement","text":"Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.","title":"Contributor License Agreement"},{"location":"contributing/#code-reviews","text":"All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Code reviews"},{"location":"glide/","text":"Glide for Jetpack Compose \u00b6 This library brings easy-to-use composable which can fetch and display images from external sources, such as network, using the Glide image loading library. GlideImage() \u00b6 The primary API is via the GlideImage() functions. There are a number of function versions available. The simplest usage is like so: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , ) This loads the data passed in with Glide , and then displays the resulting image using the standard Image composable. You can also customize the Glide RequestBuilder through the requestBuilder parameter. This allows usage of things like (but not limited to) transformations: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , requestBuilder = { val options = RequestOptions () options . centerCrop () apply ( options ) }, ) It also provides optional content 'slots', allowing you to provide custom content to be displayed when the request is loading, and/or if the image request failed: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , loading = { Box ( Modifier . matchParentSize ()) { CircularProgressIndicator ( Modifier . align ( Alignment . Center )) } }, error = { Image ( asset = imageResource ( R . drawable . ic_error )) } ) Fade-in animation \u00b6 This library has built-in support for animating loaded images in, using a fade-in animation . There are two ways to enable the animation: fadeIn parameter \u00b6 A fadeIn: Boolean parameter has been added to GlideImage (default: false ). When enabled, a default fade-in animation will be used when the image is successfully loaded: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , fadeIn = true ) Custom content \u00b6 If you need more control over the animation, or you want to provide custom layout for the loaded image, you can use the content composable version of GlideImage : GlideImage ( data = \"https://picsum.photos/300/300\" , ) { imageState -> when ( imageState ) { is ImageLoadState . Success -> { MaterialLoadingImage ( result = imageState , contentDescription = \"My content description\" , fadeInEnabled = true , fadeInDurationMs = 600 , ) } is ImageLoadState . Error -> /* TODO */ ImageLoadState . Loading -> /* TODO */ ImageLoadState . Empty -> /* TODO */ } } GIFs \u00b6 Accompanist Glide supports GIFs through Glide's own GIF support. There's nothing you need to do, it should just work. Custom RequestManager \u00b6 If you wish to provide a default RequestManager to use across all of your GlideImage calls, we provide the LocalRequestManager composition local. You can use it like so: val requestManager = Glide . with (...) // customize the RequestManager as needed . build () CompositionLocalProvider ( LocalRequestManager provides requestManager ) { // This will automatically use the value of LocalRequestManager GlideImage ( data = ... ) } For more information on composition locals, see here . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-glide:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Glide"},{"location":"glide/#glide-for-jetpack-compose","text":"This library brings easy-to-use composable which can fetch and display images from external sources, such as network, using the Glide image loading library.","title":"Glide for Jetpack Compose"},{"location":"glide/#glideimage","text":"The primary API is via the GlideImage() functions. There are a number of function versions available. The simplest usage is like so: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , ) This loads the data passed in with Glide , and then displays the resulting image using the standard Image composable. You can also customize the Glide RequestBuilder through the requestBuilder parameter. This allows usage of things like (but not limited to) transformations: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , requestBuilder = { val options = RequestOptions () options . centerCrop () apply ( options ) }, ) It also provides optional content 'slots', allowing you to provide custom content to be displayed when the request is loading, and/or if the image request failed: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , loading = { Box ( Modifier . matchParentSize ()) { CircularProgressIndicator ( Modifier . align ( Alignment . Center )) } }, error = { Image ( asset = imageResource ( R . drawable . ic_error )) } )","title":"GlideImage()"},{"location":"glide/#fade-in-animation","text":"This library has built-in support for animating loaded images in, using a fade-in animation . There are two ways to enable the animation:","title":"Fade-in animation"},{"location":"glide/#fadein-parameter","text":"A fadeIn: Boolean parameter has been added to GlideImage (default: false ). When enabled, a default fade-in animation will be used when the image is successfully loaded: GlideImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , fadeIn = true )","title":"fadeIn parameter"},{"location":"glide/#custom-content","text":"If you need more control over the animation, or you want to provide custom layout for the loaded image, you can use the content composable version of GlideImage : GlideImage ( data = \"https://picsum.photos/300/300\" , ) { imageState -> when ( imageState ) { is ImageLoadState . Success -> { MaterialLoadingImage ( result = imageState , contentDescription = \"My content description\" , fadeInEnabled = true , fadeInDurationMs = 600 , ) } is ImageLoadState . Error -> /* TODO */ ImageLoadState . Loading -> /* TODO */ ImageLoadState . Empty -> /* TODO */ } }","title":"Custom content"},{"location":"glide/#gifs","text":"Accompanist Glide supports GIFs through Glide's own GIF support. There's nothing you need to do, it should just work.","title":"GIFs"},{"location":"glide/#custom-requestmanager","text":"If you wish to provide a default RequestManager to use across all of your GlideImage calls, we provide the LocalRequestManager composition local. You can use it like so: val requestManager = Glide . with (...) // customize the RequestManager as needed . build () CompositionLocalProvider ( LocalRequestManager provides requestManager ) { // This will automatically use the value of LocalRequestManager GlideImage ( data = ... ) } For more information on composition locals, see here .","title":"Custom RequestManager"},{"location":"glide/#download","text":"repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-glide:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"insets/","text":"Insets for Jetpack Compose \u00b6 Insets for Jetpack Compose takes a lot of the ideas which drove Insetter for views, and applies them for use in composables. Usage \u00b6 To setup Insets in your composables, you need to call the ProvideWindowInsets function and wrap your content. This would typically be done near the top level of your composable hierarchy: setContent { MaterialTheme { ProvideWindowInsets { // your content } } } Note This library does not disable window decor fitting. For your view hierarchy to able to receive insets, you need to make sure to call: WindowCompat.setDecorFitsSystemWindows(window, false) from your Activity. ProvideWindowInsets allows the library to set an OnApplyWindowInsetsListener on your content's host view. That listener is used to update the value of a composition local bundled in this library: LocalWindowInsets . LocalWindowInsets holds an instance of WindowInsets which contains the value of various WindowInsets types . You can use the values manually like so: @Composable fun ImeAvoidingBox () { val insets = LocalWindowInsets . current Box ( Modifier . padding ( bottom = insets . ime . bottom )) } ...but we also provide some easy-to-use Modifier s. Modifiers \u00b6 We provide two types of modifiers for easy handling of insets: padding and size. Padding modifiers \u00b6 The padding modifiers allow you to apply padding to a composable which matches a specific type of inset. Currently we provide: Modifier.statusBarsPadding() Modifier.navigationBarsPadding() Modifier.systemBarsPadding() Modifier.imePadding() Modifier.navigationBarsWithImePadding() These are commonly used to move composables out from under the system bars. The common example would be a FloatingActionButton : FloatingActionButton ( icon = { Icon (...) }, modifier = Modifier . align ( Alignment . BottomEnd ) . padding ( 16. dp ) // normal 16dp of padding for FABs . navigationBarsPadding () // Move it out from under the nav bar ) Size modifiers \u00b6 The size modifiers allow you to match the size of a composable to a specific type of inset. Currently we provide: Modifier.statusBarsHeight() Modifier.navigationBarsHeight() Modifier.navigationBarsWidth() These are commonly used to allow composables behind the system bars, to provide background protection, or similar: Spacer ( Modifier . background ( Color . Black . copy ( alpha = 0.7f )) . statusBarsHeight () // Match the height of the status bar . fillMaxWidth () ) PaddingValues \u00b6 Compose also provides the concept of PaddingValues , a data class which contains the padding values to be applied on all dimensions (similar to a rect). This is commonly used with container composables, such as LazyColumn , to set the content padding. You may want to use inset values for content padding, so this library provides the Insets.toPaddingValues() extension function to convert between Insets and PaddingValues . Here's an example of using the system bars insets: LazyColumn ( contentPadding = LocalWindowInsets . current . systemBars . toPaddingValues () ) For a more complex example, see the EdgeToEdgeLazyColumn example: \ud83d\udea7 Experimental \u00b6 The features below are experimental, and require developers to opt-in . Animated Insets support \u00b6 Info The library now has experimental support for WindowInsetsAnimations , allowing your content is react to inset animations, such as the on screen-keyboard (IME) being animated on/off screen. The imePadding() and navigationBarsWithImePadding() modifiers are available especially for this use-case. This functionality works wherever WindowInsetsAnimationCompat works, which at the time or writing is on devices running API 21+. To enable animated insets support, you need need to new ProvideWindowInsets overload, and set windowInsetsAnimationsEnabled = true . Usage ProvideWindowInsets ( windowInsetsAnimationsEnabled = true ) { // content } You can then use the new navigationBarsWithImePadding() modifier like so: OutlinedTextField ( // other params, modifier = Modifier . navigationBarsWithImePadding () ) See the ImeAnimationSample for a working example. IME animations \u00b6 If you're using the animation insets support for IME/keyboard animations, you also need to ensure that the activity's windowSoftInputMode is set to adjustResize : <activity android:name= \".MyActivity\" android:windowSoftInputMode= \"adjustResize\" > </activity> The default value of windowSoftInputMode should work, but Compose does not currently set the flags necessary (see here ). Controlling the IME (on-screen keyboard) \u00b6 Info This library also has support for controlling the IME from scroll gestures, allowing your scrollable components to pull/push the IME on/off screen. This is acheived through the built-in NestedScrollConnection implementation returned by rememberImeNestedScrollConnection() . This functionality only works when running on devices with API 30+. Usage // Here we're using ScrollableColumn, but it also works with LazyColumn, etc. ScrollableColumn ( // We use the nestedScroll modifier, passing in the // the connection from rememberImeNestedScrollConnection() modifier = Modifier . nestedScroll ( connection = rememberImeNestedScrollConnection () ) ) { // list content } See the ImeAnimationSample for a working example. Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-insets:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit. Something not working? \u00b6 If you find that something isn't working correctly, here's a checklist to try: Check that you've called WindowCompat.setDecorFitsSystemWindows(window, false) in your Activity. Unless you do that, the window decor will consume the insets, and they will not be dispatched to your content. If it's something related to the keyboard, check that the Activity's windowSoftInputMode is set to adjustResize . Without that, IME visibility changes will not be sent as inset changes. Similarly, if you're setting android:windowFullscreen to true (or using a .Fullscreen theme), be aware that adjustResize will not work. Please see the documentation for an alternative. If you're using ProvideWindowInsets (or ViewWindowInsetObserver ) in multiple layers of your view hierarchy (i.e. in the activity, and in a fragment), you need to turn off consuming of insets. By default ProvideWindowInsets and ViewWindowInsetObserver will completely consume any insets passed to it. In the previous example, this means that the activity content will get the insets, but the fragment won't. To disable consuming, pass consumeWindowInsets = false to ProvideWindowInsets or ViewWindowInsetObserver.start() .","title":"Insets"},{"location":"insets/#insets-for-jetpack-compose","text":"Insets for Jetpack Compose takes a lot of the ideas which drove Insetter for views, and applies them for use in composables.","title":"Insets for Jetpack Compose"},{"location":"insets/#usage","text":"To setup Insets in your composables, you need to call the ProvideWindowInsets function and wrap your content. This would typically be done near the top level of your composable hierarchy: setContent { MaterialTheme { ProvideWindowInsets { // your content } } } Note This library does not disable window decor fitting. For your view hierarchy to able to receive insets, you need to make sure to call: WindowCompat.setDecorFitsSystemWindows(window, false) from your Activity. ProvideWindowInsets allows the library to set an OnApplyWindowInsetsListener on your content's host view. That listener is used to update the value of a composition local bundled in this library: LocalWindowInsets . LocalWindowInsets holds an instance of WindowInsets which contains the value of various WindowInsets types . You can use the values manually like so: @Composable fun ImeAvoidingBox () { val insets = LocalWindowInsets . current Box ( Modifier . padding ( bottom = insets . ime . bottom )) } ...but we also provide some easy-to-use Modifier s.","title":"Usage"},{"location":"insets/#modifiers","text":"We provide two types of modifiers for easy handling of insets: padding and size.","title":"Modifiers"},{"location":"insets/#padding-modifiers","text":"The padding modifiers allow you to apply padding to a composable which matches a specific type of inset. Currently we provide: Modifier.statusBarsPadding() Modifier.navigationBarsPadding() Modifier.systemBarsPadding() Modifier.imePadding() Modifier.navigationBarsWithImePadding() These are commonly used to move composables out from under the system bars. The common example would be a FloatingActionButton : FloatingActionButton ( icon = { Icon (...) }, modifier = Modifier . align ( Alignment . BottomEnd ) . padding ( 16. dp ) // normal 16dp of padding for FABs . navigationBarsPadding () // Move it out from under the nav bar )","title":"Padding modifiers"},{"location":"insets/#size-modifiers","text":"The size modifiers allow you to match the size of a composable to a specific type of inset. Currently we provide: Modifier.statusBarsHeight() Modifier.navigationBarsHeight() Modifier.navigationBarsWidth() These are commonly used to allow composables behind the system bars, to provide background protection, or similar: Spacer ( Modifier . background ( Color . Black . copy ( alpha = 0.7f )) . statusBarsHeight () // Match the height of the status bar . fillMaxWidth () )","title":"Size modifiers"},{"location":"insets/#paddingvalues","text":"Compose also provides the concept of PaddingValues , a data class which contains the padding values to be applied on all dimensions (similar to a rect). This is commonly used with container composables, such as LazyColumn , to set the content padding. You may want to use inset values for content padding, so this library provides the Insets.toPaddingValues() extension function to convert between Insets and PaddingValues . Here's an example of using the system bars insets: LazyColumn ( contentPadding = LocalWindowInsets . current . systemBars . toPaddingValues () ) For a more complex example, see the EdgeToEdgeLazyColumn example:","title":"PaddingValues"},{"location":"insets/#experimental","text":"The features below are experimental, and require developers to opt-in .","title":"\ud83d\udea7 Experimental"},{"location":"insets/#animated-insets-support","text":"Info The library now has experimental support for WindowInsetsAnimations , allowing your content is react to inset animations, such as the on screen-keyboard (IME) being animated on/off screen. The imePadding() and navigationBarsWithImePadding() modifiers are available especially for this use-case. This functionality works wherever WindowInsetsAnimationCompat works, which at the time or writing is on devices running API 21+. To enable animated insets support, you need need to new ProvideWindowInsets overload, and set windowInsetsAnimationsEnabled = true . Usage ProvideWindowInsets ( windowInsetsAnimationsEnabled = true ) { // content } You can then use the new navigationBarsWithImePadding() modifier like so: OutlinedTextField ( // other params, modifier = Modifier . navigationBarsWithImePadding () ) See the ImeAnimationSample for a working example.","title":"Animated Insets support"},{"location":"insets/#ime-animations","text":"If you're using the animation insets support for IME/keyboard animations, you also need to ensure that the activity's windowSoftInputMode is set to adjustResize : <activity android:name= \".MyActivity\" android:windowSoftInputMode= \"adjustResize\" > </activity> The default value of windowSoftInputMode should work, but Compose does not currently set the flags necessary (see here ).","title":"IME animations"},{"location":"insets/#controlling-the-ime-on-screen-keyboard","text":"Info This library also has support for controlling the IME from scroll gestures, allowing your scrollable components to pull/push the IME on/off screen. This is acheived through the built-in NestedScrollConnection implementation returned by rememberImeNestedScrollConnection() . This functionality only works when running on devices with API 30+. Usage // Here we're using ScrollableColumn, but it also works with LazyColumn, etc. ScrollableColumn ( // We use the nestedScroll modifier, passing in the // the connection from rememberImeNestedScrollConnection() modifier = Modifier . nestedScroll ( connection = rememberImeNestedScrollConnection () ) ) { // list content } See the ImeAnimationSample for a working example.","title":"Controlling the IME (on-screen keyboard)"},{"location":"insets/#download","text":"repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-insets:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"insets/#something-not-working","text":"If you find that something isn't working correctly, here's a checklist to try: Check that you've called WindowCompat.setDecorFitsSystemWindows(window, false) in your Activity. Unless you do that, the window decor will consume the insets, and they will not be dispatched to your content. If it's something related to the keyboard, check that the Activity's windowSoftInputMode is set to adjustResize . Without that, IME visibility changes will not be sent as inset changes. Similarly, if you're setting android:windowFullscreen to true (or using a .Fullscreen theme), be aware that adjustResize will not work. Please see the documentation for an alternative. If you're using ProvideWindowInsets (or ViewWindowInsetObserver ) in multiple layers of your view hierarchy (i.e. in the activity, and in a fragment), you need to turn off consuming of insets. By default ProvideWindowInsets and ViewWindowInsetObserver will completely consume any insets passed to it. In the previous example, this means that the activity content will get the insets, but the fragment won't. To disable consuming, pass consumeWindowInsets = false to ProvideWindowInsets or ViewWindowInsetObserver.start() .","title":"Something not working?"},{"location":"picasso/","text":"Picasso for Jetpack Compose \u00b6 This library brings easy-to-use composable which can fetch and display images from external sources, such as network, using the Picasso v2 image loading library. PicassoImage() \u00b6 The primary API is via the PicassoImage() functions. There are multiple function versions available. The simplest usage is like so: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , ) This loads the data passed in with Picasso , and then displays the resulting image using the standard Image composable. You can also customize the Picasso RequestCreator through the requestBuilder parameter. This allows usage of things like (but not limited to) transformations: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , requestBuilder = { rotate ( 90f ) } ) It also provides optional content 'slots', allowing you to provide custom content to be displayed when the request is loading, and/or if the image request failed: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , loading = { Box ( Modifier . matchParentSize ()) { CircularProgressIndicator ( Modifier . align ( Alignment . Center )) } }, error = { Image ( asset = imageResource ( R . drawable . ic_error )) } ) Fade-in animation \u00b6 This library has built-in support for animating loaded images in, using a fade-in animation . There are two ways to enable the animation: fadeIn parameter \u00b6 A fadeIn: Boolean parameter is available on PicassoImage (default: false ). When enabled, a default fade-in animation will be used when the image is successfully loaded: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , fadeIn = true ) Custom content \u00b6 If you need more control over the animation, or you want to provide custom layout for the loaded image, you can use the content composable version of PicassoImage : PicassoImage ( data = \"https://picsum.photos/300/300\" , ) { imageState -> when ( imageState ) { is ImageLoadState . Success -> { MaterialLoadingImage ( result = imageState , contentDescription = \"My content description\" , fadeInEnabled = true , fadeInDurationMs = 600 , ) } is ImageLoadState . Error -> /* TODO */ ImageLoadState . Loading -> /* TODO */ ImageLoadState . Empty -> /* TODO */ } } Custom Picasso \u00b6 If you wish to provide a default Picasso to use across all of your PicassoImage calls, we provide the LocalPicasso composition local. You can use it like so: val picasso = Picasso . Builder (...) // Customize as required . build () CompositionLocalProvider ( LocalPicasso provides picasso ) { // This will automatically use the value of LocalPicasso PicasoImage ( data = ... ) } For more information on composition locals, see here . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-picasso:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Picasso"},{"location":"picasso/#picasso-for-jetpack-compose","text":"This library brings easy-to-use composable which can fetch and display images from external sources, such as network, using the Picasso v2 image loading library.","title":"Picasso for Jetpack Compose"},{"location":"picasso/#picassoimage","text":"The primary API is via the PicassoImage() functions. There are multiple function versions available. The simplest usage is like so: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , ) This loads the data passed in with Picasso , and then displays the resulting image using the standard Image composable. You can also customize the Picasso RequestCreator through the requestBuilder parameter. This allows usage of things like (but not limited to) transformations: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , requestBuilder = { rotate ( 90f ) } ) It also provides optional content 'slots', allowing you to provide custom content to be displayed when the request is loading, and/or if the image request failed: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , loading = { Box ( Modifier . matchParentSize ()) { CircularProgressIndicator ( Modifier . align ( Alignment . Center )) } }, error = { Image ( asset = imageResource ( R . drawable . ic_error )) } )","title":"PicassoImage()"},{"location":"picasso/#fade-in-animation","text":"This library has built-in support for animating loaded images in, using a fade-in animation . There are two ways to enable the animation:","title":"Fade-in animation"},{"location":"picasso/#fadein-parameter","text":"A fadeIn: Boolean parameter is available on PicassoImage (default: false ). When enabled, a default fade-in animation will be used when the image is successfully loaded: PicassoImage ( data = \"https://picsum.photos/300/300\" , contentDescription = \"My content description\" , fadeIn = true )","title":"fadeIn parameter"},{"location":"picasso/#custom-content","text":"If you need more control over the animation, or you want to provide custom layout for the loaded image, you can use the content composable version of PicassoImage : PicassoImage ( data = \"https://picsum.photos/300/300\" , ) { imageState -> when ( imageState ) { is ImageLoadState . Success -> { MaterialLoadingImage ( result = imageState , contentDescription = \"My content description\" , fadeInEnabled = true , fadeInDurationMs = 600 , ) } is ImageLoadState . Error -> /* TODO */ ImageLoadState . Loading -> /* TODO */ ImageLoadState . Empty -> /* TODO */ } }","title":"Custom content"},{"location":"picasso/#custom-picasso","text":"If you wish to provide a default Picasso to use across all of your PicassoImage calls, we provide the LocalPicasso composition local. You can use it like so: val picasso = Picasso . Builder (...) // Customize as required . build () CompositionLocalProvider ( LocalPicasso provides picasso ) { // This will automatically use the value of LocalPicasso PicasoImage ( data = ... ) } For more information on composition locals, see here .","title":"Custom Picasso"},{"location":"picasso/#download","text":"repositories { mavenCentral () } dependencies { implementation \"dev.chrisbanes.accompanist:accompanist-picasso:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"updating/","text":"Updating & releasing Accompanist \u00b6 This doc is mostly for maintainers. New features & bugfixes \u00b6 All new features should be uploaded as PRs against the main branch. Once merged into main , they should be merged into the snapshot branch: git checkout main && git pull git checkout snapshot && git pull # Create branch for PR git checkout -b snapshot_main_merge # Merge in the main branch git merge main # Push to GitHub Jetpack Compose Snapshots \u00b6 We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch. Updating to a newer Compose snapshot \u00b6 As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit dependencies.kt : Update the Libs.AndroidX.Compose.snapshot property to be the snapshot number Ensure that the Libs.AndroidX.Compose.version property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review. Releasing \u00b6 Once the next Jetpack Compose version is out, we're ready to push a new release: #1: Merge snapshot into main \u00b6 First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot #2: Update dependencies \u00b6 Edit dependencies.kt : Update the Libs.AndroidX.Compose.snapshot property to be an empty string ( val snapshot = \"\" ) Update the Libs.AndroidX.Compose.version property to the new Compose version ( 1.0.0-alpha03 for example). Make sure the project builds and test pass: ./gradlew check Commit the changes. #3: Bump the version number \u00b6 Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name. #4: Push to GitHub \u00b6 Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central. #5: Create release \u00b6 Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website . #6: Prepare the next development version \u00b6 The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"Update guide"},{"location":"updating/#updating-releasing-accompanist","text":"This doc is mostly for maintainers.","title":"Updating &amp; releasing Accompanist"},{"location":"updating/#new-features-bugfixes","text":"All new features should be uploaded as PRs against the main branch. Once merged into main , they should be merged into the snapshot branch: git checkout main && git pull git checkout snapshot && git pull # Create branch for PR git checkout -b snapshot_main_merge # Merge in the main branch git merge main # Push to GitHub","title":"New features &amp; bugfixes"},{"location":"updating/#jetpack-compose-snapshots","text":"We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch.","title":"Jetpack Compose Snapshots"},{"location":"updating/#updating-to-a-newer-compose-snapshot","text":"As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit dependencies.kt : Update the Libs.AndroidX.Compose.snapshot property to be the snapshot number Ensure that the Libs.AndroidX.Compose.version property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review.","title":"Updating to a newer Compose snapshot"},{"location":"updating/#releasing","text":"Once the next Jetpack Compose version is out, we're ready to push a new release:","title":"Releasing"},{"location":"updating/#1-merge-snapshot-into-main","text":"First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot","title":"#1: Merge snapshot into main"},{"location":"updating/#2-update-dependencies","text":"Edit dependencies.kt : Update the Libs.AndroidX.Compose.snapshot property to be an empty string ( val snapshot = \"\" ) Update the Libs.AndroidX.Compose.version property to the new Compose version ( 1.0.0-alpha03 for example). Make sure the project builds and test pass: ./gradlew check Commit the changes.","title":"#2: Update dependencies"},{"location":"updating/#3-bump-the-version-number","text":"Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name.","title":"#3: Bump the version number"},{"location":"updating/#4-push-to-github","text":"Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central.","title":"#4: Push to GitHub"},{"location":"updating/#5-create-release","text":"Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website .","title":"#5: Create release"},{"location":"updating/#6-prepare-the-next-development-version","text":"The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"#6: Prepare the next development version"},{"location":"using-snapshot-version/","text":"Using a Snapshot Version of the Library \u00b6 If you would like to depend on the cutting edge version of the Accompanist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.accompanist:accompanist-coil:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below). Using Jetpack Compose Snapshots \u00b6 If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable Accompanist release forcing an older version of those libraries. We publish snapshot versions of Accompanist which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.accompanist:accompanist-coil:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Snapshots"},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","text":"If you would like to depend on the cutting edge version of the Accompanist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.accompanist:accompanist-coil:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below).","title":"Using a Snapshot Version of the Library"},{"location":"using-snapshot-version/#using-jetpack-compose-snapshots","text":"If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable Accompanist release forcing an older version of those libraries. We publish snapshot versions of Accompanist which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'dev.chrisbanes.accompanist:accompanist-coil:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Using Jetpack Compose Snapshots"}]}